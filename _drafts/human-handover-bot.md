---
layout: post
title: Transferring chat to a human agent using Microsoft Bot Framework 
comments: true
tags: [Microsoft Bot Framework, Bots, Chat Bots, Conversational Apps, Agent, Human, Live Agent Transfer]
description: A tutorial on how to perform live agent transfer / human handover using Microsoft Bot Framework
---

> Source Code: [Human Handover Bot](https://github.com/ankitbko/human-handoff-bot)


One of the frequent questions which I am asked is how to transfer chat to a human from the bot. It is specially necessary if your bot is in space of customer service. Chat bots are not meant to (or atleast, not mature enough currently) to completely replace humans. Many a times chat bot will fail to answer satisfactorily or user would just want to talk to a human from the start. When this happens the chatbot should transfer the chats to a human agent or a customer care representative. But how can we achieve that?


In this article I will give an overview on how we can integrate a live chat into our bot using Microsoft Bot Framework. Microsoft Bot Framework is highly extensible and lets us do this easily. The source code is available over at my github repo.


### High Level Overview

Our bot would be central piece to whole solution. Apart from performing all it's normal functionality, our bot would also act as a proxy between user and agent. So what is required to create this feature and who are the actors involved?

#### Actors Involved

- **Bot**: Well, we have our bot (duh!).
- **Users**: Users are our customers who would be using our bot. Our users can be on any channel which are supported by Bot Framework.
- **Agent**: Agents are humans who would chat with our users. Our agent will also need a chat window. For this we will use [Bot Framework Web Chat](https://github.com/Microsoft/BotFramework-WebChat) as a dashboard for our agents.

### Running the bot

Let us first run the bot and see how it works. Nothing helps better in understanding than running the code and seeing it first hand.  

To run the bot follow the steps - 

1. Create a [Luis app](https://luis.ai) by importing `LuisModel\AgentTransfer.json`.  
The bot uses Luis to understand if user wants to talk to an agent. If you don't want to use Luis, I have included an `EchoDialog` class which would also work. You will need to modify the code to start `EchoDialog` instead of `TransferLuisDialog` when message arrives (left as exercise to the reader). If you do this, go to step 3.

2. Get the *ModelId* and *SubscriptionKey* of the Luis App and paste it into `LuisModel` attribute in `TransferLuisDialog.cs`.

3. Run the solution by pressing `F5`. By default it should start at port 3979. If not, note the port it runs on and stop debugging.

4. We will use [ngrok](https://ngrok.com) to debug the bot locally. Download and run `ngrok` using command `ngrok.exe http --host-header=rewrite <port number>`. Copy the **Forwarding** URL (https) which is genrated by ngrok.

5. Register a new bot in [Bot Framework Portal](https://dev.botframework.com/bots/new) using URL generated by ngrok. Copy the Microsoft App Id and App Password and paste it in `web.config`.

6. Agent Dashboard uses *Direct Line* as a channel. So enable direct line and keep it's *Secret Key* handy.

7. Run the solution once again.


To open Agent Dashboard go to [http://localhost:3979/agentdashboard/index.html?s=DIRECTLINE_SECRET_KEY](http://localhost:3979/agentdashboard/index.html?s=DIRECTLINE_SECRET_KEY). Change the port number accordingly if it is not 3979. Notice the query string `?s=`. Enter the *Direct Line secret key* as the value of the query string.  

You will get the page similar to below.

![Agent Dashboard](/assets/images/posts/human-agent/agent_dashboard.png)

Click on *Connect* button to **register** yourself as an agent. If you get successfully registered, the heading in the page will change to show the "Connected" status. This makes the agent **available** for chat.


Use any other channel (skype or web chat at bot portal) to simulate an user. Currently there is only one Luis intent `AgentTransfer` which is triggered by typing "*Connect me with customer care*". Enter it to start talking with agent.  
**Using emulator will not work.**

> If you are using `EchoDialog`, agent transfer can be achieved by typing anything starting with letter '*a*'. Typing anything else will just echo back.

Once user has initiated the conversation with an agent, any messages user sends will be delivered to the agent (instead of being handled by bot) and vice versa.  

To stop conversation with user, click on *Stop Conversation with User* button on agent dashboard. Click on *Disconnect* to remove agent from **available** pool. 


We will see how each of these works shortly, but first let us understand some of the concepts involved in it.


### Building Blocks

Let us understand what we did while running the code. We will divide the flow into logical groups -

- **Initiating Transfer**: A user can **initiate** a transfer to an agent anytime. Initiation is successful if an agent is **available** for chat. A user can only talk to **one** agent at a time. Once initiated, all the messages from user will be routed to the agent instead of being handled by current `Dialog`.

- **Agent Availability**: An agent is termed **available** if he is **not** already in an exisiting conversation with a user. This effectively means that an agent can only talk to **one** user at a time. In other words Agent and User have *1:1* mapping.

- **Agent User Mapping**: We established that an agent and an user have *1:1* mapping. Since we have to route messages to and fro, we must maintain this mapping somewhere.

- **Message Routing**: Message is routed by fetching the *Agent User Mapping* and sending the current message to it's counterpart. For example, if a user sends a message, we fetch the agent associated with that user, and send the message text to the agent. Same applies the other way around.

- **Stopping Conversation**: Stopping the conversation should prevent bot from routing any further messages to and fro agent and user. This effectively means that we **remove** the *Agent User Mapping*. Stopping the conversation will also make the agent **available** once again.

- **Disconnecting Agent**: Disconnecting an agent means we remove the agent from **availability** pool. No further **initiation** can happen with this particular agent. 

### Solution Structure

![Solution Structure](/assets/images/posts/human-agent/soln.png)

The most important pieces of code which I want to highlight are

- **Agent** folder contains everything related to agent management and routing implementation.
- **AgentDashboard** folder contains **index.html** which has Web Chat control embedded. We will use this page for agent to chat. How it works we will see later.
- **Scorable** folder contains two `IScorable` implementations which serves as middleware to route messages. We will get into its details later.
 - **AgentModule** class contains `Autofac` registrations for our project.  


There are five key interfaces in our solution, all lying in **Agent** folder. They are - 

- `IAgentProvider`: Contains methods for *Adding*, *Removing* and getting *Next Available* agent. When agent connects, we *add* the agent to availability pool by using `AddAgent` method. Similarly `RemoveAgent` method is used to remove the agent. `GetNextAvailableAgent` method should get the *next available* agent from availability pool **and** remove the agent from the pool in an atomic way, so that same agent is not returned twice.

- `IUserToAgent`: As name suggests, is used to send messages from user to agent. It's method `SendToAgentAsync` does exactly that. It contains two other methods - `IntitiateConversationWithAgentAsync` to **initate** a transfer for first time and `AgentTransferRequiredAsync` to check if routing is required.

- `IAgentToUser`: Contains a single method `SendToUserAsync` to send the message from agent to user.

- `IAgentUserMapping`: Contains methods for adding, removing and fetching the *Agent User Mapping*.

- `IAgentService`: Acts as a business class mainly for registering agent, unregistering agent and stopping a conversation. In addtion it contains other methods to check if agent is in existing conversation and whether the message is from an *actual/valid* agent.

Apart from the interfaces, there are two scorables in **Scorable** folder. `Scorable` in Bot Framework acts as a middleware to the incoming messages. Using `Scorable` we can intercept message and take decisions before it is sent to the waiting dialog. We have following scorables in place - 

- `AgentToUserScorable`: Intercepts messages coming from *agent* and routes it to *user* **if** *agent* is in conversation with *user*.

- `UserToAgentScorable`: Intercepts messages coming from *user* and routes it to *agent* **if** *user* is in conversation with *agent*.


### Availability Pool

#### Connecting Agent
Check if it is valid agent

#### Disconnecting Agent


### Agent User Mapping


### Message Routing

#### User to Agent Route

#### Agent to User Route

### Stopping Conversation

### Agent Dashboard Explained

### Conclusion

I have been waiting for CRIS for a long time and it is finally available to use. It works so much better than Bing Speech API and looks really promising. However I don't think that Calling Bot is matured enough yet. It looks a little sketchy and entire flow is not smooth, but it is still in preview so lets wait and watch. Meanwhile try out training [Acoustic Model](https://cris.ai/Home/Help#Creating a custom acoustic model) and let me know in the comments how did it work out.  